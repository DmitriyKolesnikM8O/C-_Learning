#include <iostream>

int square(int x, int y) {
    return x * y;
}

int main() {
    int x = 5;
    int y = 3;
    int z = square(x, y);
    std::cout << z;
}
/*
Поясняшки:
1 - записывается в стэк переменная x со своим значением
2 - записывается в стек переменная y со своим значением
3 - записывается placeholder в стек для z
4 - записывается текущий адрес памяти инструкций в стек, чтобы мы знали, где возобновить 
программу после выхода из функции square
5 - записывается указатель кадра для текущей функции на стек. Все в текущем стеке далее будет
рассматриваться, как локальное для функции. Это необходимо, потому что различные вызовы функций
могут иметь разные размеры для кадров стека
6 - выполнение переходит к адресу памяти функции square
7 - параметры функции x и y кладутся на стек, значение определяется аргументом вызова
8 - возвращающее значение записывается в placeholder
9 - поток возвращаемся по адресу на стек и дальше выполняем программу

*/

int& square(int x, int y) {
    return x * y;
}

int main() {
    int x = 3;
    int y = 5;
    int& i = square(x, y); 
}

/*
До 8 пункта все происходит точно также
Далее в placeholder записывается адрес возвращаемого значения
После выхода из функции локальные переменные также очищаются из стека
Далее должен присвоиться переменной i адрес x. Но это значение лежит выше по стеку и
переписывается
Поэтому образуется Undefined Behavior, то есть неопределенное поведение
В итоге поведение функции становится неопределенным, потому что когда-то она будет работать,
а когда нет
*/

/*
Современные компиляторы плюсов добавляют определенные оптимизации, чтобы
код работал лучше и быстрее.
Например, RVO, - оптимизация возвращаемого значения.
Это применяется к операторам типа: return Type{}, например, когда
возвращается структура
Дополнительного заполнителя (placeholder) не выделяется, копирования не происходит. Внешний объект, которому присваивается значения функции, просто конструируется на в месте вызова.

Еще есть оптимизация NRVO. Здесь речь идет про именованное возвращаемое значение, то есть когда просто переменную возвращаем. Заполнитель тоже не создается, копирование тоже не выполняется. Вместо этого локальный объект, который фунция возвращает, и тот объект, которому это присваивается, просто рассматриваются, как единое целое.
В результате на месте вызова создается только один номер. 
Эта оптимизация уже не является обязательной, однако большинство компиляторов выполняет ее.

Далее, встраивание (Inlining). Если функция маленькая, например, как моя выше, то ее вызов просто заменяется встраиванием кода в момент вызова.
то есть условно: int i = square(x * y);
Такое встраивание возможно лишь в том случае, если компилятор видит в том числе и полный код функции. А это не всегда получается, если мы компилируем разные куски программы.
Встраивание во многих других ЯП, например, в Java, просто невозможно из-за полиморфизма и ограничения на то, что функции могут выполняться только в момент выполнения программы.


*/

