#include <cstdint>
#include <vector>
/*
 Время жизни разных объектов:
 - Automatic - Время жизни определяется {} - локальные переменные, параметры функции
 - Dynamic - Время жизни объекта контролируется посредством спец. инструкций - объекты, независимые от области
 действия
 - Thread - Время жизни привязано к началу и концу потока - хранение на потоке
 - Static - Время жизни привязано к началу и концу программы - одиночные объекты и так далее

 Практическая реализация модели памяти в плюсах ограничена возможностями платформы (процессор, архитектура, ось)

 HEAP (Free Store):
 - используется для динамических объектов, для векторов, set, map...
 - используется для хранения большого количества данных
 - возможность выделять или освобождать объект по требованию
 - медленная аллокация (распределение), так как нужно искать незанятое пространство

 STACK:
 - используется для объектов с автоматическим временем хранения: локальные переменные и так далее
 - маленький, обычно пару мегабайт
 - быстрая аллокация, ведь новые объекты просто кладутся на верхушку
 - объекты освобождаются в порядке, обратном их созданию
 - невозможно освободить объекты ниже самого верхнего

 В плюсах нет сборки мусора, хотя вроде как какая-то поддержка включена, но ее вроде как хотят исключить


*/


int main() {
//    std::int16_t = 1234; // 0000010011010010, 2 bytes, 16 bits
    int i = 4; //first variable on stack
    for (int j = 0; j < i; j++) {
        if (j > 2) {    //second variable, update with update j
            int k = 2 * j; //third variable, create when j greater than 2
        }
    }

    //delete variable, thirst - k, after j and then i
    

    //каждый вектор содержит буфер, который хранится в куче, где и лежит вся информация
    //а сам объект вектора, который хранит указатель на внутренний массив, лежит на стеке, так как это
    //локальная переменная
    //после выделения блоков памяти на куче их размер изменить нельзя, так как у нас нет гарантии, что
    //непосредственно за выделенным блоком еще есть свободное место
    //Поэтому реализация динамического массива отделяет объект массива от фактического блока памяти для 
    //хранения его значений
    std::vector<int> v {0, 1, 2, 3, 4};


    //динамически выделяется новый, больший блок памяти, туда все копируется, а старый уничтожается
    //size() - количество элементов в векторе
    //resize() - новое количество элементов
    //capacity() - количество доступных слотов памяти
    //reserve() - новая capacity
    v.push_back(6);

    std::vector<int> new_v; //capacity = 0; size = 0 
    new_v.push_back(7); //capacity = 1; size = 1 
    v.reserve(4); //capacity = 4; size = 1
    v.push_back(8); //capacity = 4; size = 2
    v.push_back(10); //capacity = 4; size = 3
    v.push_back(12); // capacity = 4; size = 4
    
    v.resize(6, 0); // 7 8 10 12 0 0 capacity = 6; size = 6
    //если заранее, хотя бы приблизительно, известно число элементов в векторе - лучше сразу их зарезервировать
    //это позволит избежать ненужного копирования на этапе роста






}
