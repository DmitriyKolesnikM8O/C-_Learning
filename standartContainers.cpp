//array<T, size> - fixed-size contiguous array
//vector<T> - dynamic contiguous array, "default" container
//deque<T> - double-ended queue, fast insert/erase at both ends
//list<T> - doubly-linked list, fast insert, erase, splicing, slower than
//vector
//Forward_list<T> - singly-linked list. fsast insert, erasem splicing.
//slower than vector

std::vector<int> a {4, 7, 8, 9};
std::vector<int> b {1, 3, 5};
bool equal = (a == b); //false
b = a;
equal = (a == b); //true
a[0] = 4
equal = (a == b); //false

std::vector<int> v_float {1.f, 2.f, 3.f};
std::vector<int> v_double {1., 2., 3.};

struct p1 {int x; int y};
std::vector v {p1{1, 2}}//std::vector<p1>

//array<T, size>
//- произвольный доступ без накладных расходов
//- быстрый обход
//- size has to be a constant (=known at compile time)
//- not support size-changing operations (resize, insert, erase)
//- потенциально медленно, если элемент имеет высокую стоимость копирования, назначения (изменение порядка элементов требует их копирования)

#include <array>
std::array<int, 6> a {1, 2, 3, 4, 5, 6};
std::cout << a.back(); //6

std::array<int, 4> b {1, 2, 3, 4};
b = a; //error
//all digits from array in stack

//vector<T>
//- произвольный доступ без накладных расходов
//- быстрый обход
//- вставка в конец занимается амортизированную константу
//- потенциально медленно, если доминируют вставки / стирания в начале или в случайных позициях
//- потенциально медленно, если элемент имеет высокую стоимость копирования, назначения (изменение порядка элементов требует их копирования)
//- все операции, которые могут изменять емкость(insert, push_back), могут сделать недействительными ссылки на любой элемент вектора
//- потенциально длительное время распределения для большого количества элементов
v.insert(begin(v), {7,8}); 

//удаление элементов из вектора никогда не меняет его емкость и следовательно никогда не освобождает память.
//Освободить можно так:
vector<int> v;
//add a lot of elements
//erase elements
v = vector<int>(v);
//or
v.swap( vector<int>(v) );

//опасно использовать итераторы после вставки или чистки, потому что они могут быть недействительными
//лучше создавать новую переменную
i = v.insert(i, 8);
std::cout << *i;


//deque<T>
//- случайный доступ с постоянным временем
//- быстрый обход
//- хорошая производительность вставки или удаления с обоих концов
//- вставка не делает недействительными указатели или ссылки на элементы
//- потенциально медленно, если вставка или очистка происходят в рандомных местах
//- потенциально медленно, если элементы имеют высокую стоимость копирования или изменения
//- потенциально долгое выделение памяи для большого количества элементов
#include <deque>

std::deque<int> d {0, 0, 0};
d.push_back(1);
d.push_front(2);



//list<T>
//- операции реструктуризации не требуют перемещения или копирования элементов, то есть подходит для хранения больших объектов с высокой стоимостью копирования или назначения
//- постоянное время сращивания
//- рандомный доступ только за линейное время
//- медленный обход из-за плохой локальности памяти

#include <list>

std::list<int> l {3}; // 3

l.push_back(2); // 3 2
l.push_front(4); // 4 3 2
l.splice(begin(l) + 1,
       list<int>{8, 4, 7}); // 4 8 4 7 3 2
l.sort();
l.unique(); //delete repeatadle elements


//Forward_list<T>
//- меньше памяти, чем list
//- операции реструктуризации не требуют перемещения или копирования элементов, то есть подходит для хранения больших объектов с высокой стоимостью копирования или назначения
//- постоянное время сращивания
//- рандомный доступ только за линейное время
//- возможен только прямой обход

#include <forward_list>

std::forward_list<int> l {23, 42, 4};

l.insert_after(begin(l), 5); // 23 5 42 4
l.insert_after(begofe_begin(l), 88) // 88 23 5 42 4


//1 выбор среди всех контейнеров - vector
//- если элементов мало и они не будут добавляться - array
//- если удаление или вставка только в начале или конце - deque
//- если копирование элементов в рандомных местах - list
//- если требуется чуть меньше памяти - forward_list



