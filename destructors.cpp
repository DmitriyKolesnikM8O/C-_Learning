//деструктор - функция, которая автоматически вызывается, когда объект выходит из области или явно уничтожается, например, с помощью delete

#include <iostream>
#include <vector>

class Point {int x; int y; };
class Test {
    std::vector<Point> w_;
    std::vector<int> v_;
    int i_ = 0;
public:
    Test() { std::cout << "Constructor\n"; }
    ~Test() { std::cout << "Destructor\n"; }
};

int main() {
    std::cout << "before\n";
    if (1) {
        Test x;
    }
    std::cout << "after\n";
}
//Programm output: before -> Constructor -> Destructor -> after
//Дескрутор членов данных выполняется в порядке, обратном их декларации. Это происходит автоматически и не может быть изменено
//То есть в коде выше переменная x пропадает после выхода из цикла - запуск ~Test()
//Сперва удаляется i_, потом v_, затем w_.
//при удалении, например, v_, вызывается дескрутор для вектора - ~vector<int> v_, удаляет элементы из буфера, аллоцирует память в кучу.
//
//!Объект считается владельцев ресурса(памяти, дескриптора файла и так далее), если он отвечает за его жизненный цикл, инициализация, создание, уничтожение!
//В C++ используется семантика значений, то есть переменные ссылаются на сами объекты, это не просто указатель или поинтер
//И поскольку время жизни членов привязано к содержащему их объекту, нет необходимости в сборщике мусора
//
//В сторонних библиотеках, которые управляют памятью или другими ресурсами, обычно присутствуют функции потипу init и finalize, которые вызывает сам программист для инициализации и удаления.
//
//В итоге может возникнуть такая широкая проблема, как утечка ресурсов. То есть про функцию finalize просто забывают, что приводит к утечке ресурсов или зависанию программы.
//
//Решение проблемы: использование RAII Wrapper. Вызов инициализирующей функции в конструкторе, вызов finalize в декструкторе.
//Также в таком классе-оболочке, можно хранить дополнительный контект, например, о подключении.
//Саму же оболочку(Wrapper) лучше сделать некопируемой, поскольку она обрабатывает уникальные ресурсы.

#include <gpulib.h>


class GPUContext {
    int gpuid_;
public:
    explicit
    GPIContext(int gpuid = 0): gpuid_{gpuid} {
        gpulib_init(gpuid_);
    }
    ~GPUContext () {
        gpulib_finalize(gpuid_);
    }
    //[[nodiscart]] - возвращаемое значение функции не предназначено для удаления    
    [[nodiscard]] int gpu_id () const noexcept {
        return gpuid_;
    }

    //make non-copyable:
    GPUContext (GPUContext const&) = delete;
    GPIContext& operator = (GPUContext const&) = delete;
};

int main() {
    ...
    if (...) {
        GPUContext gpu;
    } //Automatically finalized!!!
}

//Example: RAII Logging
class Fire {...};
class DeviceID {...};

class UsageLog {
public:
    explicit UsageLog (File const&);
    ...
    void armed (DeviceID);
    void disarmed (DeviceID);
    void fired (DeviceID);
};

class Device {
    DeficeID id_;
    Usagelog* log_;
    ...
public:
    explicit
    Device (Device id, UsageLog* log = nullptr):
        id_{id}, log_{log}, ...
    {
        if (log_) log_->armed(id_);      
    }

    ~Device () if (log_) log_->disarmed(id_);

    void fire () {
        ...
        if (log_) log_->fired(id_);
    }
};
//log.txt:
//device 1   armed
//device 1   fired
//device 2   armed
//device 2   fired
//device 2   disarmed
//device 1   fired
//device 1   disarmed


in main() {
    File file {"log.txt"};
    UsageLog log {file};
    ...
    Device d1 {DeviceID{1}, &log};
    d1.fire();
    {
        Device d2 {Device{2}, &log};
        d2.fire();
    }
    d1.fire();
}

//стоит избегать специаьных member-function, если не ннужно управлять ресурсами в RAII-стиле. В большинстве случаев достаточно init и finalize, сгенерированных компилятором
//
//Справка по RAII:
//Получение ресурсов как инициализация или RAII — это метод программирования на языке C++, который 
//связывает жизненный цикл ресурса, который должен быть получен перед использованием (выделенная динамическая 
//память, поток выполнения, открытый сокет, открытый файл, заблокированный мьютекс, дисковое пространство, 
//подключение к базе данных — все, что существует в ограниченном количестве), со временем жизни объекта.
//Данный метод гарантирует, что ресурс будет доступен любой функции, которая может получить доступ к объекту.
//Также он гарантирует, что все ресурсы будут освобождены, когда закончится время жизни контролирующего их объекта, в порядке, обратном получению.
//
//В современных версиях C++ почти никогда не нужно писать деструкторы, потому что сегодня стратегии управления памятью в основном инкапсулированы в выделенные классы, вроде умных указателей.



















